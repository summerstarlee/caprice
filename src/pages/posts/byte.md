---
title: "数制与编码"
pubDate: "2023-09-25"
description: "数制转换和数制运算"
hero: "/images/tooltt-fontlogo.png"
tags: [ "math" ]
layout: "../../layouts/BlogPostLayout.astro"
---

## 常见数制的表示方法

1. 二进制 （Binary）
   * （10101B
   * （101012   2是下标
2. 八进制 （Octal）
   * （4603)O   O是字母
   * （4603)8   8是下标

3. 十进制 (Decimal)
   * (1250)D
   * (1250)10
4. 十六进制

## 原码、反码、补码
***正数的原码、反码、补码 都是本身***

### 原码
***符号位加上真值的绝对值***
```
[+1]原= 0000 0001
[-1]原= 1000 0001
```

### 反码
***正数的反码是其本身、负数的反码是原码的基础上，符号位不变、其余值取反***
```
[+1]反= 0000 0001
[-1]反= 1111 1110
```
### 补码
***正数的补码是其本身、负数的反码是原码的基础上，符号位不变、其余值取反、最后 +1***
```
[+1]补 = 0000 0001
[-1]补 = [1000 001]原 = [1111 1110]反 = [1111 1111]补
```

## 为什么有原码、反码、补码
根本原因是***位运算只有加法运算***

计算十进制的表达式：1 - 1 = 0

1. 如果使用原码：
```
1-1 
= 1 + (-1) 
= [0000 0001]原 + [1000 0001]原 
= [1000 0010]原 
= -2
```
符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。

2. 为了解决原码做减法的问题， 出现了反码
```
1-1 
= 1 + (-1) 
= [0000 0001]原 + [1000 0001]原 
= [0000 0001]反 +  [1111 1110]反 
= [1111 1111]反 
= [1000 0000]原 
= -0 
```
使用反码计算， 可以计算出真值部分的结果， 但是却出现了 -0 的结果， 计算机表示+0 和-0是不同的，`[0000 0000]原`和 `[1000 0000]原`。

3. 使用补码解决0的符号问题和0有两个编码的问题
```
1-1 
= 1 + (-1) 
= [0000 0001]原 + [1000 0001]原 
= [0000 0001]反 +  [1111 1110]反 
= [0000 0001]补 + [1111 1111]补
= [1 0000 0000]补    // 前面的进位 1 不在计算机字长里
= [0000 0000]补   // 正数的原码、反码、补码都是其本身
= 0 
```
